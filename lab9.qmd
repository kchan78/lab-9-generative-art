---
title: "Lab 9: Generative Art"
author: "Katherine Chan"
format: html
editor: visual
---

```{r}
library(dplyr)
library(ggplot2)
library(tibble)
library(scales)
library(ggthemes)
```

```{r}
mpg |>
  ggplot(aes(displ, hwy, colour = drv)) + 
  geom_point()

mpg |>
  ggplot(aes(displ, hwy, colour = drv, size = cyl)) + 
  geom_point(show.legend = FALSE) + 
  theme_void() + 
  scale_color_brewer()

mpg |>
  ggplot(aes(displ, hwy, colour = drv)) + 
  geom_point(show.legend = FALSE, size = 4) + 
  geom_point(show.legend = FALSE, size = 1, colour = "#222222") + 
  coord_polar() + 
  theme_void() + 
  scale_color_brewer()
```


```{r}
#| warning: FALSE
mpg |> 
  ggplot(aes(displ, hwy, color = model)) +
  geom_point(shape = 8, show.legend = FALSE) +
  geom_spoke(aes(angle = cty, radius = cyl), show.legend = FALSE)  +
  coord_polar() + 
  theme_void() + 
  scale_color_brewer()
  
```


# My styled plot
```{r}
sample_data <- function(seed = NULL, n = 100){
  if(!is.null(seed)) set.seed(seed)
  dat <- tibble(
    x0 = runif(n),
    y0 = runif(n),
    x1 = x0 + runif(n, min = -.5, max = .5),
    y1 = y0 + runif(n, min = -.5, max = .5),
    shade = runif(n), 
    size = runif(n),
    shape = factor(sample(0:22, size = n, replace = TRUE)),
    alpha = runif(n)
  )
}
```

```{r}
sample_canva <- function(seed = NULL) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]]
}

sample_named_colours <- function(n = NULL, seed = 1) {
  if(!is.null(n)) set.seed(seed)
  sample(colours(distinct = TRUE), n)
}
```

```{r}
dat <- sample_data(n = 100, seed = 1) 
dat2 <- sample_data(n = 100, seed = 456)

pal <- sample_canva(seed = 2)
pal2 <- sample_named_colours(n = 2, seed = 7)
show_col(pal)
show_col(pal2)

#pal2 <- c("antiquewhite", "#234643")
```



```{r}
#| warning: FALSE

dat <- sample_data(n = 100, seed = 6) 
dat2 <- sample_data(n = 100, seed = 2)

pal <- sample_canva(seed = 90)
pal2 <- sample_named_colours(n = 2, seed = 8)

ggplot(
    data = dat,
    mapping = aes(
      x = x0,
      y = y0,
      xend = x1,
      yend = y1,
      colour = shade,
      size = 1/size,
      alpha = alpha
    )) + 
    scale_colour_gradientn(colours = pal) + 
    scale_fill_gradient(low = pal2[[1]], high = pal2[[2]]) +
    scale_size(range = c(0, 10)) + 
    theme_void() + 
    guides(
      colour = guide_none(),
      size = guide_none(),
      fill = guide_none(),
      shape = guide_none(),
      alpha = guide_none()
    ) +
 # coord_polar(clip = "off") +
  stat_density2d(geom="tile", 
                 aes(fill = after_stat(density)), 
                 contour = FALSE) +
  stat_density2d(data = dat2 |> mutate(x = x0 + 3,
                                       y = y0 + 9), 
                 geom="tile", 
                 aes(fill = after_stat(density)), 
                 contour = FALSE) +
    geom_point(shape = 8) + 
  geom_curve(
    data = dat2 |> mutate(size = 1/(size)), 
    aes(curvature = alpha)
  )
```


# Iterative Art
```{r}
library(Rcpp)
library(ggplot2)
library(tibble)
library(purrr)
library(dplyr)
library(ggthemes)
library(tictoc)
```





```{r}
unboxer_base <- function(iterations, layers, seed = NULL) {
  
  if(!is.null(seed)) set.seed(seed)
  
  # coefficients defining affine layer transforms, A_i
  coeffs <- array(
    data = runif(9 * layers, min = -1, max = 1), 
    dim = c(3, 3, layers)
  )
  
  # list of variant functions, g_j
  funs <- list(
    function(point) point + 0.1 * sin(point),
    function(point) point + 0.2 * cos(point),
    function(point) point + 0.6 * sin(point)
  )
  
  # updater function: apply the layer, then the function
  # point[3]:treating color as special
  update <- function(point, layer, transform) {
    f <- funs[[transform]]
    z <- point[3]
    point[3] <- 1
    transformed_point <- point %*% coeffs[,,layer]
    
    # Check if any element of the transformed point is negative, zero, or missing
    if (any(is.na(transformed_point)) || any(transformed_point <= 0)) {
      # If yes, add a small constant to ensure all elements are positive
      transformed_point <- transformed_point + abs(min(transformed_point, 
                                                       na.rm = TRUE)) + 1e-6
    }
    
    # Apply the function to the transformed point
    point <- f(transformed_point)
    point[3] <- (point[3] + z)/2
    return(point)
  }


  
  # update <- function(point, layer, transform) {
  #   f <- funs[[transform]]
  #   z <- point[5]
  #   point[5] <- 1
  #   point <- f(point %*% coeffs[,,layer])
  #   point[5] <- (point[5] + z)/2
  #   return(point)
  # }
  
  # initial point
  point0 <- matrix(
    data = runif(3, min = -1, max = 1), 
    nrow = 1,
    ncol = 3
  )
  
  # sample points
  layer_ind <- sample(layers, iterations, replace = TRUE)  
  trans_ind <- sample(length(funs), iterations, replace = TRUE)  
  points <- accumulate2(layer_ind, trans_ind, update, .init = point0)
  
  # tidy up, add columns, and return
  points <- matrix(unlist(points), ncol = 3, byrow = TRUE)
  points <- cbind(
    points,
    c(0, layer_ind),
    c(0, trans_ind)
  )
  return(points)
}
```

```{r}
sample_canva2 <- function(seed = NULL, n = 5) {
  
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]] |>
    (\(x) colorRampPalette(x)(n))()  
}
```

```{r}
unbox_art <- function(data, seed = NULL, size = 1) {
  
  # convert to data frame and sample a palette
  data <- data |> as.data.frame() |> as_tibble()
  names(data) <- c("x", "y", "c", "l", "t")[1:ncol(data)]
  shades <- sample_canva2(seed)
  
  # render image as a scatter plot
  ggplot(data, aes(x, y, colour = c)) +
    geom_point(
      size = size,
      stroke = 0,
      show.legend = FALSE
    ) + 
    theme_void() + 
    coord_equal(xlim = c(-5, 5), ylim = c(-5, 5)) + 
    scale_colour_gradientn(colours = shades) + 
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    theme(panel.background = element_rect(
      fill = shades[1], colour = shades[1]
    ))
}
```


```{r}
mil <- 10000
unboxer_base(3 * mil, layers = 3, seed = 7) |> 
  unbox_art(seed = 198, size = .1)
```

```{r}
set.seed(4)
# Number of points on the circle
num_points <- 100

# Function to generate circular shapes
generate_circle <- function(num_points) {
  angle <- seq(0, 2 * pi, length.out = num_points + 1)
  x <- cos(angle)[-1]
  y <- sin(angle)[-1]
  data.frame(x = x, y = y)
}

# Create the circular shape
circle_points <- generate_circle(num_points)

# Chaos Game variant functions for circular shapes
funcs <- list(
  function(p) p + circle_points[sample(num_points, 1), ] / 2
)

# Chaos Game function
chaos_game <- function(funcs, start, n) {
  # Initialize the point sequence
  points <- vector("list", length = n + 1)
  points[[1]] <- start
  
  # Iterate through each step
  for (i in 1:n) {
    
    # Sample an index randomly from the list
    random_index <- sample(length(funcs), 1)
    
    # Get the randomly sampled variant function from the list
    rand_func <- funcs[[random_index]]
    
    # Apply the chosen function to the last point
    points[[i + 1]] <- rand_func(points[[i]])
  }
  
  # Combine the points into a data frame
  do.call(rbind, points)
}

# Set the number of iterations
n <- 10000

# Perform the chaos game
result <- chaos_game(funcs, c(0, 0), n)

# Plot the result
ggplot(result, aes(x, y)) +
  geom_point(color = "blue", size = 0.1) +
  theme_void()

```

# Tiles and Tess
```{r}
library(dplyr)
library(tibble)
library(ggplot2)
library(ggforce)
library(deldir)
library(ggthemes)
#library(voronoise)
library(tictoc)
#library(ambient)
library(purrr)
library(tidyr)
library(stringr)
library(truchet)
library(sf)
```


```{r}
unboxy <- function(iterations, layers) {
  
  coeffs <- array(
    data = runif(16 * layers, min = -1, max = 1), 
    dim = c(4, 4, layers)
  )
  
  point0 <- matrix(
    data = runif(4, min = -1, max = 1), 
    nrow = 1,
    ncol = 4
  )
  
  funs <- list(
    function(point) point + (sum(point ^ 2)) ^ (1/3),
    function(point) sin(point),
    function(point) 2 * sin(point),
    function(point) cos(point) - 1
  )
  
  update <- function(point, t) {
    l <- sample(layers, 1)
    f <- sample(funs, 1)[[1]]
    z <- point[4]
    point[4] <- 1
    point <- f(point %*% coeffs[,,l])
    point[4] <- (point[4] + z)/2
    return(point)
  }
  
  points <- accumulate(1:iterations, update, .init = point0)
  points <- matrix(unlist(points), ncol = 4, byrow = TRUE)
  points <- as_tibble(as.data.frame(points)) 
  names(points) <- c("x", "y", "val", "n")
  return(points)
}
```


```{r}
set.seed(1)
dat <- unboxy(iterations = 10000, layers = 5) 

#dat
ggplot(dat, aes(x, y)) + 
  geom_point(colour = "black", size = 0.1, show.legend = FALSE) +
  coord_equal(xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5)) + 
  theme_void()
```


```{r}
sample_canva <- function(seed = NULL, n = 4) {
  if(!is.null(seed)) set.seed(seed)
  sample(ggthemes::canva_palettes, 1)[[1]] |>
    (\(x) colorRampPalette(x)(n))()  
}
```

```{r}
show_col(sample_canva(seed = 234, n = 9))
```


```{r}
pic <- ggplot(dat, aes(x, y, fill = val, size = size)) +
  theme_void() + 
  coord_equal(xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5)) + 
  scale_fill_gradientn(colours = sample_canva(seed = 234, n = 9)) + 
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0))

pic +
  geom_voronoi_tile(
    colour = "white",
    size = .05, 
    show.legend = FALSE
  ) 
```



